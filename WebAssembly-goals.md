# Goals for WebAssembly support

Issue [#14976](https://gitlab.haskell.org/ghc/ghc/-/issues/14976)
suggests adding a WebAssembly (Wasm) back end to GHC. This page
elaborates what WebAssembly support might look like.  (Actually
getting there is a goal of the [Asterius
project](https://asterius.netlify.app/).)

## What Wasm support looks like

Full Wasm support means that GHC's compiler, run-time system, and boot
libraries meet these goals:

  - The `ghc` binary can be built as a cross-compiler that generates
    `wasm32` object files and executables. The generated object files
    and executables can be linked with (cross-compiled) C/C++ code.

  - GHC's run-time system and the C/C++ sources in the boot libraries
    can be cross-compiled to `wasm32-wasi`. That's the 32-bit Wasm
    instruction set supported by the [WebAssembly System Interface
    (WASI)](https://wasi.dev/).

  - Haskell code compiled with GHC can interoperate with JavaScript, but
    JavaScript is needed only when Haskell code contains `foreign
    import/export javascript`. If a Haskell program does not use foreign
    JavaScript functions, it can run on a WebAssembly engine that does
    not support JavaScript.

  - It is possible to build an application using a mix of Haskell and
    JavaScript, with JavaScript in charge.  As an example, JavaScript
    can call a Haskell function that may block the Haskell thread it is
    running on, in which case GHC's run-time system will arrange for a
    prompt return of control to JavaScript, as required by JavaScript's
    concurrency model.

  - Haskell code can call an asynchronous JavaScript function (one that
    returns a `Promise`), in which case the calling Haskell thread is
    suspended until the `Promise` resolves or rejects.  Other Haskell
    threads may continue execution.  The function must be declared to be
    asynchronous when imported, but at a call site an asynchronous
    JavaScript function is treated exactly like a synchronous JavaScript
    function or even a Haskell function; the need to suspend the calling
    thread is handled transparently to the programmer.

  - Template Haskell is supported.

  - Cabal and Cabal-based build tools work out of the box; that is,
    `cabal build` does the right thing. Cabal requires no special
    patches; it needs only a configuration that tells it which `ghc` and
    `ghc-pkg` executables to use.

  - The compiler itself (the `ghc` binary) is not expected to run on a
    WebAssembly platform---the platform is intended for
    cross-compilation only.

  - GHCi on WebAssembly is _not_ supported.

## How the goals might be accomplished

Of special concern to GHC's implementors:

  - GHC will need a new back end that can emit WebAssembly
    modules. These modules will serve as object code.

  - GHC's generated code can be linked with compiled C/C++ code, provided
    the emitted WebAssembly modules conform to the C/C++ [linking
    convention](https://github.com/WebAssembly/tool-conventions/blob/main/Linking.md).

  - Absent use of JavaScript FFI in Haskell source code, WebAssembly
    modules generated by GHC will have only one external dependency:
    [WASI](https://wasi.dev/), which serves as a system-call layer. Such
    modules can be executed by any WebAssembly engine that implements
    WASI; the engine need not support JavaScript.

    If the Haskell program entry point or one of its transitive
    dependencies uses `foreign import` or `foreign export` with a
    JavaScript convention, GHC will generate code that works only on a
    WebAssembly engine that supports JavaScript. GHC's interactions with
    JavaScript will be supported by a small adjunct to GHC's run-time
    system, which will be hand-written in JavaScript.

  - GHC's existing run-time system will need modification to run on the
    WebAssembly platform. But the existing non-threaded run-time system
    can continue to manage heap layout, the Haskell stack, calling
    conventions, and so on, as on other 32-bit platforms.

    Support for storage management and scheduling will need to be
    altered so that the run-time system supports a third platform `wasi`
    in addition to the current `posix` and `win32` platforms.
