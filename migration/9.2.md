[[_TOC_]]

# GHC 9.2.x Migration Guide


This guide summarises the changes you may need to make to your code to migrate from GHC 9.0 to GHC 9.2. This guide complements the GHC 9.2.x release notes which should be consulted as well.

---

## Compiler changes

### Kind inference for data family instances is pickier

GHC's kind inference for data/newtype instance declarations is slightly more restrictive than before. The new rule is this: in data/newtype instance declararations (unlike ordinary data/newtype declarations) we do *not* look at the constructor declarations when inferring the kind of the instance header.  The principle is that *the instantiation of the data instance should be apparent from the header alone*.

A consequence of this change is that some programs that compiled on previous versions of GHC will no longer be accepted under 9.2. Here is such an example:

```hs
data family T :: k -> Type
data instance T a = MkT1 a
```

Previous versions of GHC would look at the `MkT1` constructor to infer that `a` has kind `Type` and accept the data instance. GHC 9.2, however, only looks of the header (`data instance T a`) and concludes that `a` has kind `k`. As a result, the `MkT1` constructor is ill kinded, so GHC will throw an `Expected a type, but ‘a’ has kind ‘k’` error.

The workaround is to simply make the kind of `a` explicit:

```hs
data family T :: k -> Type
data instance T (a :: Type) = MkT1 a
```

### Stricter scope-checking for associated type family instances

GHC is now stricter about checking for out-of-scope type variables on the right-hand sides of associated type family instances that are not bound on the left-hand side. As a result, some programs that were accidentally accepted in previous versions of GHC will now be rejected, such as this example:

```hs
class Funct f where
  type Codomain f
instance Funct ('KProxy :: KProxy o) where
  type Codomain 'KProxy = NatTr (Proxy :: o -> Type)
```

Where:

```hs
data Proxy (a :: k) = Proxy
data KProxy (t :: Type) = KProxy
data NatTr (c :: o -> Type)
```
      
GHC will now reject the `o` on the right-hand side of the `Codomain` instance as being out of scope, as it does not meet the requirements for being explicitly bound (as it is not mentioned on the left-hand side) nor
implicitly bound (as it is not mentioned in an _outermost_ kind signature). This program can be repaired in a backwards-compatible way by mentioning `o` on the left-hand side:

```hs
instance Funct ('KProxy :: KProxy o) where
  type Codomain ('KProxy @o) = NatTr (Proxy :: o -> Type)
  -- Alternatively,
  -- type Codomain ('KProxy :: KProxy o) = NatTr (Proxy :: o -> Type)
```

### `UndecidableInstances` no longer implies `FlexibleContexts` in instance declarations

Previous versions of GHC would accept the following program, as the use of `UndecidableInstances` would imply the `FlexibleContexts` extension:

```hs
{-# LANGUAGE UndecidableInstances #-}
module Foo where

data T1 a
data T2 a = MkT2 (T1 a)

instance Eq (T1 a) => Eq (T2 a) where
  MkT2 x == MkT2 y = x == y
```

GHC 9.2 tightens up the specification of `UndecidableInstances`, and one consequence of this is that `UndecidableInstances` no longer implies `FlexibleContexts`. As a result, the program above will no longer typecheck on GHC 9.2 or later:

```
$ ~/Software/ghc-9.1.20210201/bin/ghc Foo.hs
[1 of 1] Compiling Foo              ( Foo.hs, Foo.o )

Foo.hs:7:10: error:
    • Non type-variable argument in the constraint: Eq (T1 a)
      (Use FlexibleContexts to permit this)
    • In the instance declaration for ‘Eq (T2 a)’
  |
7 | instance Eq (T1 a) => Eq (T2 a) where
  |          ^^^^^^^^^^^^^^^^^^^^^^
```

As the error message indicates, this can be fixed in a backwards-compatible way by enabling `FlexibleContexts`.

### Subsumption-related changes to operator sections

GHC 9.2 implements further simplifications related to subsumption when typechecking, in addition to other simplifications made in 9.0. In particular, these changes concern the way that operator sections are typechecked. Some uses of operator sections involving operators with nested `forall`s or contexts in their type signatures will no longer typecheck in GHC 9.2, such as in this example:

```hs
f :: a -> forall b. b -> a
f x _ = x

g :: a -> a
g = (`f` "hello")
```

This will now fail with:

```
Bug.hs:8:6: error:
    • Couldn't match type: forall b. b -> a
                     with: String -> a
      Expected: a -> String -> a
        Actual: a -> forall b. b -> a
    • In the expression: f
      In the expression: `f` "hello"
      In an equation for ‘g’: g = (`f` "hello")
    • Relevant bindings include g :: a -> a (bound at Bug.hs:8:1)
  |
8 | g = (`f` "hello")
  |      ^^^
```

`g` can be made to typecheck once more through eta expansion:

```hs
g :: a -> a
g x = x `f` "hello"
```

---

## Library changes

### `base-4.16.*`

#### `Nat` is a synonym for `Natural`

The `Nat` kind is now a type synonym for `Natural` (from `Numeric.Natural`). As a consequence, one must enable `TypeSynonymInstances` in order to define instances for `Nat`.

#### Changes to the `(<=)` and `(<=?)` type families

A new kind-polymorphic `Compare` type family was added in the `Data.Type.Ord` module, and moreover, the `(<=?)` and `(<=)` type families from `GHC.TypeNats` are now defined in terms of `Compare`. This has two important repercussions:

* GHC can no longer deduce that all natural numbers are greater than or equal to zero. For instance, this program will no longer typecheck:

  ```hs
  test1 :: Proxy (0 <=? x) -> Proxy True
  test1 = id
  ```
* When `(<=)` or `(<=?)` are used very generically, a kind may need to be provided.  For example, this program:

  ```hs
  test2 :: Proxy (x <=? x) -> Proxy True
  test2 = id
  ```

  Will now generate a type error because GHC does not know the kind of `x`. To fix this, one must provide an explicit kind, perhaps by changing the type to:

  ```hs
  test2 :: forall (x :: Nat). Proxy (x <=? x) -> Proxy True
  ```

### `ghc-prim-0.8.*`

TODO: Mention `Int{8,16,32}#`/`Word{8,16,32}#`-related changes

### `template-haskell-2.18.*`

Template Haskell now supports the ability to write type applications as arguments to data constructors in patterns. As a result, the `ConP` constructor of `Pat` now accepts a list of `Type`s that represent its visible type arguments, if any are provided:

```diff
 data Pat
   = ...
-  | ConP Name [Pat]
+  | ConP Name [Type] [Pat]
```

For example, the `(Just x)` in `f (Just x) = x` is now represented as `ConP 'Just [] [VarP x]`.