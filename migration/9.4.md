[[_TOC_]]

# GHC 9.4.x Migration Guide


This guide summarises the changes you may need to make to your code to migrate from GHC 9.2 to GHC 9.4. This guide complements the GHC 9.4.x release notes which should be consulted as well.

---

## Compiler changes

### Ambiguous types containing a TypeError

GHC rejects certain ambiguous types when they contain an insoluble constraint, even with `-XAllowAmbiguousTypes`. For example:

```haskell
{-# LANGUAGE AllowAmbiguousTypes #-}

class C (a :: Type)
instance (Maybe w ~ Bool) => C a
```

This program is rejected because `w` is ambiguous and `Maybe w ~ Bool` is an insoluble constraint. This behaviour isn't new, but it now extends to `TypeError` constraints too. For example, the following program used to be accepted, but it is now rejected:

```haskell
{-# LANGUAGE AllowAmbiguousTypes #-}

class C (a :: Type)
instance TypeError (ShowType w) => C a
```

In practice, the ambiguity might be hidden in a kind (especially now that `-XPolyKinds` is enabled by default, with `-XGHC2021`). For example:

```haskell
class C (a :: Type)
instance TypeError (ShowType Any) => C a
```

is ambiguous because the kind of `Any` is not specified. Specifying a kind, e.g.:

```haskell
class C (a :: Type)
instance TypeError (ShowType (Any @Type)) => C a
```

allows the program to be accepted again.

### Changes around hs-boot files

Previous versions of GHC were not very precise about adding dependencies on hs-boot files therefore there were situations where a boot file existed but it wasn't compiled. Now we make sure corresponding boot files are compiled, so you may encounter errors relating to unused boot files. The correct fix is probably to just delete the file.

### `(~)` is now a type operator

The use of `(~)` now requires `TypeOperators` instead of `GADTs` or `TypeFamilies`, and it is exported by `Data.Type.Equality` and `Prelude`. For backwards-compatibility reasons, old code using `(~)` that does not meet these criteria will continue to compile, but it may produce warnings:

* If `(~)` is used but `TypeOperators` is not enabled, GHC will produce a `-Wtype-equality-requires-operators` warning. This warning can be fixed by enabling `TypeOperators`.
* If `(~)` is used but is not imported transitively via `Data.Type.Equality` or `Prelude`, GHC will produce a `-Wtype-equality-out-of-scope` warning. This warning can be fixed by either importing one of these modules or, in the case where a custom `Prelude` is being used, re-exporting `(~)` from the custom `Prelude`.

### Type inference changes involving simplifiable constraints

GHC 9.4 is more eager to simplify constraints in certain situations, which can have user-facing ramifications. Here is an example of a program that will no longer typecheck in 9.4 (but would typecheck in earlier versions):

```hs
type family F x

f :: (F a ~ Maybe a, Show (F a)) => a -> IO ()
f _ = pure ()

g :: (F a ~ Maybe a, Show (F a)) => a -> IO ()
g = go
  where
    go = f
```

GHC 9.4 will give `go` the type `(F a ~ Maybe a, Show a) => a -> IO ()`, as it will rewrite `Show (F a)` to `Show (Maybe a)` and then use the top-level `Show` instance for `Maybe` to simplify `Show (Maybe a)` to `Show a`. This causes a type error when trying to typecheck `g = go`, as `g` is unable to satisfy `go`'s `Show a` constraint.

To fix the error, add an explicit type signature to `go`:

```hs
g :: (F a ~ Maybe a, Show (F a)) => a -> IO ()
g = go
  where
    go :: (F a ~ Maybe a, Show (F a)) => a -> IO ()
    go = f
```

### Parser plugins have a different type

The type of `GHC.Plugins.parsedResultAction` was changed from
```haskell
parsedResultAction :: [CommandLineOption] -> ModSummary -> HsParsedModule -> Hsc HsParsedModule
```
to
```haskell
parsedResultAction :: [CommandLineOption] -> ModSummary -> ParsedResult -> Hsc ParsedResult
```
The `ParsedResult` contains both the `HsParsedModule` from before, as well as a `PsMessages` value, which allows you to modify the warning and error messages from the parser, assuming none of them prevented the AST from being built. To retain the old behavior, simply pass the messages through unchanged and only modify the `parsedResultModule` field of the `ParsedResult`.

---

## Library changes

### `base-4.17`

#### Word64/Int64 use Word64#/Int64#

Before 9.4, `Int64/Word64` were wrappers for `Int#/Word#` on 64-bit architectures and for `Int64#/Word64#` on 32-bit architectures. Now the latter are always used (`Int64#/Word64#`). Users of the unboxed values must use `Int64#/Word64#` primops on every architecture.

TODO examples

### `ghc-prim-0.9`

#### reallyUnsafePtrEquality#

`GHC.Exts.reallyUnsafePtrEquality#` is now levity-polymorphic and heterogeneous, with type:

```haskell
reallyUnsafePtrEquality#
  :: forall {l :: Levity} {k :: Levity}
            (a :: TYPE ('BoxedRep l))
            (b :: TYPE ('BoxedRep k))
  . a -> b -> Int#
```

This means that it is no longer necessary to use `unsafeCoerce#` when using `reallyUnsafePtrEquality#` on values of different types, or whose types are unlifted, such as `Array#`, `ByteArray#`, `SmallArray#`. In fact, it is no longer possible to use `unsafeCoerce#` in this way, as GHC doesn't support unsaturated levity-polymorphic primops. This means that code such as

```haskell
hetPtrEq :: a -> b -> Bool
hetPtrEq a b = isTrue# (unsafeCoerce# reallyUnsafePtrEquality# a b)
```

will no longer typecheck. To fix this, simply remove the call to `unsafeCoerce#`:

```haskell
hetPtrEq :: a -> b -> Bool
hetPtrEq a b = isTrue# (reallyUnsafePtrEquality# a b)
```

#### `withDict` replaces `magicDict`

`GHC.Prim.magicDict` has been replaced by `GHC.Magic.withDict`. `withDict` takes its arguments in a different order than `magicDict`:

```haskell
withDict :: forall {rr :: RuntimeRep} st dt (r :: TYPE rr). st -> (dt => r) -> r
```

This change was motivated by:

* The old type of `magicDict`, `forall a. a` was difficult to use correctly.
* Moreover, `magicDict` was not expressive enough to handle classes with multiple type arguments (e.g., `Typeable @k (a :: k)`.

Here is an example of how to adapt existing code that uses `magicDict`:

```haskell
newtype SNat (n :: Nat) = SNat Natural

class SNatI (n :: Nat) where
  natSingI :: SNat n

data WrapN a b = WrapN (KnownNat    a => Proxy a -> b)

withSNat :: forall a b.
            (KnownNat a => Proxy a -> b)
         -> SNat a      -> Proxy a -> b
withSNat f x y = magicDict (WrapN f) x y
```

Whereas `magicDict` requires an intermediate data type like `WrapN` to function, `withDict` only requires explicit type applications. As a result, `withSNat` can be defined in terms of `withDict` without the need for `WrapN`:

```haskell
withSNat f x y = withDict @(SNat a) @(KnownNat a) x f y
```

#### Pointer equality primops

The following functions have been moved from `GHC.Prim` to `GHC.Exts`:
  - `sameMutableArray#`, `sameSmallMutableArray#`, `sameMutableByteArray#`
     and `sameMutableArrayArray#`,
  - `sameMutVar#`, `sameTVar#` and`sameMVar#`,
  - `sameIOPort#`,
  - `eqStableName#`.

Code that imported these functions from `GHC.Prim` will need to be modified to import them from `GHC.Exts` instead. Note that this is a backwards-compatible change, as these primops are already re-exported by `GHC.Exts` before GHC 9.4.