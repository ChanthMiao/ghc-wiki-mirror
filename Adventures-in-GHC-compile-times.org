#+title: Adventures in GHC build times
#+author: doyougnu
#+date: <2021-07-09 Fri>

* What
  This page serves as a central repository for the effort to track and improve
  GHC compiler performance, where performance in this context specifically means
  build times. I (Jeff) will try to track ideas, issues, and relevant merge
  requests for future work as well.

* Ideas

** IntMap becomes unbalanced

*** Hypothesis
    ~IntMap~ is used throughout the compiler, typically storing ~Unique~ for
    keys. The idea here is that the ~IntMap~ is becoming very unbalanced. While
    this isn't a problem in and of itself because under the hood ~IntMap~'s are
    Patricia trie in specific cases if the keys share a long prefix of bits
    then the spine of the tree needs to be rebuilt for every insertion, thus
    leading to performance degradation. See [[https://gitlab.haskell.org/ghc/ghc/-/issues/19820#note_351497][this comment]] for a more precise
    discussion.

*** Status
    Unconfirmed. In progress, working on (2) in courses of action

*** Evidence
    To gather evidence that the unbalancing is happening we need to either
    inspect the heap or print the trees during a build. Any other ideas
    appreciated.

*** The Fix
    The current ~Unique~ implementation is big endian, i.e., it stores the "key"
    in the most significant bits of an ~Int~. There are several paths forward:

    1. hash the keys to make the probability of a long prefix more unlikely
       thereby increasing
    2. move the keys to little endian to observe a difference

*** Relevant Issues
     - https://gitlab.haskell.org/ghc/ghc/-/issues/19820
     - https://gitlab.haskell.org/ghc/ghc/-/issues/18541#note_292432 see Sylvain
       Henry's comment on ~IntMap.lookup~
     - https://github.com/haskell/containers/pull/340#issuecomment-610400875

*** Relevant Merge Requests
    (1) has been tried in [[https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5068][!5068]] by [[https://gitlab.haskell.org/sgraf812][@sgraf812]], who implemented the key hash but
    didn't fix compilation errors

*** Courses of Action
    1. Retrieve direct evidence of the tree becoming unbalanced
    2. Revive [[https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5068][!5068]], fix the compilation errors and benchmark
    3. Create a patch with [[https://github.com/haskell/containers/pull/340][novel IntMap implementation]] and benchmark
    4. Use a mutable map for the bits of the compiler which are already in IO.
       This hasn't been tried but would be a significant change as we would have
       to add the ~hashtables~ package as a boot or core library (not sure
       which). Although [[https://github.com/haskell-perf/dictionaries][benchmarks by Chris Done]] indicate a 1000x speedup over
       pure IntMap's.
    5. Ed Kmett has also experimented with Clojure-style RRB trees in his [[https://github.com/ekmett/transients][here]].
       The implementation is unfinished and there are no benchmarks. We could
       finish the implementation, benchmark it against the standard ~IntMap~, if
       it looks good then patch it into the compiler and benchmark.

*** What was learned
    - ~Not worth the cost~: From (3) in Courses of Action we saw that the
      ~bounded-intmap~ implementation as a drop in replacement for the current
      intmaps results in significant slowdowns (as much as 70%) in certain
      phases for certain packages. Furthermore the max speedup observed was 12%.
      Furthermore the nofib results only showed degradation's in compile time
      performance. See my analysis [[https://gitlab.haskell.org/ghc/ghc/-/issues/19820#note_364086][here]] for more details and data.


** IntMap ~lookup~ performs allocation

*** Hypothesis
    IntMap lookup performs allocation due to the key being specialized in its
    definition. See SPJ's breakdown [[https://gitlab.haskell.org/ghc/ghc/-/issues/20069][here]].

*** Status
    Confirmed without direct evidence.

*** Evidence
    By inspection of source code. Also noticed in [[https://gitlab.haskell.org/ghc/ghc/-/issues/18541#note_292432][this comment]], however not
    confirmed with direct evidence. See Sebastian's [[https://gitlab.haskell.org/ghc/ghc/-/issues/20069#note_362952][comment]] about the ~go~
    closure.

*** The Fix
    Sylvain Henry has a patch [[https://gitlab.haskell.org/ghc/ghc/-/issues/18541#note_292432][here]] but only tested the intmap-benchmarks.

*** Relevant Issues
     - https://gitlab.haskell.org/ghc/ghc/-/issues/19820 The low-hanging fruit
       issue kicked off by Richard Eisenberg's ticky ticky profile.
     - https://gitlab.haskell.org/ghc/ghc/-/issues/18541#note_292432 see Sylvain
       Henry's comment on ~IntMap.lookup~
     - https://gitlab.haskell.org/ghc/ghc/-/issues/20069 SPJ's IntMap issue

*** Relevant Merge Requests

*** Relevant Patches
    - see https://gitlab.haskell.org/ghc/ghc/-/issues/18541#note_292432

*** Courses of Action
    - Implement and benchmark Sylvain Henry's patch, benchmark it for building
      entire packages not just the intmap-benchmark

    - I took a deep dive into the core, stg of the lookup. First thing to notice
      is the core:
       #+begin_src haskell
       $wlookup
         = \ @a_s5OwJ ww_s5OwO w_s5OwL ->
             join {
               exit_X9 dt_d5E7p x_a5sqR
                 = case ==# ww_s5OwO dt_d5E7p of {
                     __DEFAULT -> Nothing;
                     1# -> Just x_a5sqR
                   } } in
             joinrec {
               go3_s5GTZ ds_d5zfo
                 = case ds_d5zfo of {
                     Bin dt_d5E7n dt1_d5E7o l_a5sqO r_a5sqP ->
                       let { m_s5GU1 = int2Word# dt1_d5E7o } in
                       case /=#
                              (word2Int#
                                 (and#
                                    (int2Word# ww_s5OwO)
                                    (xor# (int2Word# (negateInt# (word2Int# m_s5GU1))) m_s5GU1)))
                              dt_d5E7n
                       of {
                         __DEFAULT ->
                           case and# (int2Word# ww_s5OwO) m_s5GU1 of {
                             __DEFAULT -> jump go3_s5GTZ r_a5sqP;
                             0## -> jump go3_s5GTZ l_a5sqO
                           };
                         1# -> Nothing
                       };
                     Tip dt_d5E7p x_a5sqR -> jump exit_X9 dt_d5E7p x_a5sqR;
                     Nil -> Nothing
                   }; } in
             jump go3_s5GTZ w_s5OwL
       #+end_src
       Notice all those ~word2Int~ and ~int2Word~'s? The hypothesis here is that
      these are allocating. Even if they aren't they waste time in the
      conversion. You can see it more clearly in the stg:
       #+begin_src haskell
       $wlookup =
           \r [ww_s5Wim w_s5Win]
               let-no-escape {
                 exit_s5Wio =
                     \r [dt_s5Wip x_s5Wiq]
                         case ==# [ww_s5Wim dt_s5Wip] of {
                           __DEFAULT -> Nothing [];
                           1# -> Just [x_s5Wiq];
                         };
               } in
                 let-no-escape {
                   Rec {
                   go3_s5Wis =
                       \r [ds_s5Wit]
                           case ds_s5Wit of {
                             Bin dt_s5Wiv dt1_s5Wiw l_s5Wix r_s5Wiy ->
                                 case int2Word# [dt1_s5Wiw] of m_s5Wiz {
                                 __DEFAULT ->
                                 case word2Int# [m_s5Wiz] of sat_s5WiB {
                                 __DEFAULT ->
                                 case negateInt# [sat_s5WiB] of sat_s5WiC {
                                 __DEFAULT ->
                                 case int2Word# [sat_s5WiC] of sat_s5WiD {
                                 __DEFAULT ->
                                 case xor# [sat_s5WiD m_s5Wiz] of sat_s5WiE {
                                 __DEFAULT ->
                                 case int2Word# [ww_s5Wim] of sat_s5WiA {
                                 __DEFAULT ->
                                 case and# [sat_s5WiA sat_s5WiE] of sat_s5WiF {
                                 __DEFAULT ->
                                 case word2Int# [sat_s5WiF] of sat_s5WiG {
                                 __DEFAULT ->
                                 case /=# [sat_s5WiG dt_s5Wiv] of {
                                   __DEFAULT ->
                                       case int2Word# [ww_s5Wim] of sat_s5WiI {
                                       __DEFAULT ->
                                       case and# [sat_s5WiI m_s5Wiz] of {
                                         __DEFAULT -> go3_s5Wis r_s5Wiy;
                                         0## -> go3_s5Wis l_s5Wix;
                                       };
                                       };
                                   1# -> Nothing [];
                                 };
                                 };
                                 };
                                 };
                                 };
                                 };
                                 };
                                 };
                                 };
                             Tip dt_s5WiK x_s5WiL -> exit_s5Wio dt_s5WiK x_s5WiL;
                             Nil -> Nothing [];
                           };
                   end Rec }
                 } in  go3_s5Wis w_s5Win;
       #+end_src
       In the stg there are a lot of temporary fully evaluated variables like
      ~sat_s5WiB~ which is just the result of ~word2Int~ applied to the result
      of ~int2Word~ on variable ~m~, clearly what a waste!

      We can see why in the source code for ~lookup~ in ~IntMap~:
      #+begin_src haskell
      lookup :: Key -> IntMap a -> Maybe a
      lookup !k = go
        where
          go (Bin p m l r) | nomatch k p m = Nothing
                           | zero k m  = go l
                           | otherwise = go r
          go (Tip kx x) | k == kx   = Just x
                        | otherwise = Nothing
          go Nil = Nothing
      #+end_src
      Nothing too unusual but if we look at those helper functions we'll find a
      bunch of superfluous ~int2Word~ calls:
      #+begin_src haskell
      -- | Should this key follow the left subtree of a 'Bin' with switching
      -- bit @m@? N.B., the answer is only valid when @match i p m@ is true.
      zero :: Key -> Mask -> Bool
      zero i m
        = (natFromInt i) .&. (natFromInt m) == 0
      {-# INLINE zero #-}

      nomatch,match :: Key -> Prefix -> Mask -> Bool

      -- | Does the key @i@ differ from the prefix @p@ before getting to
      -- the switching bit @m@?
      nomatch i p m
        = (mask i m) /= p
      {-# INLINE nomatch #-}

      -- | Does the key @i@ match the prefix @p@ (up to but not including
      -- bit @m@)?
      match i p m
        = (mask i m) == p
      {-# INLINE match #-}


      -- | The prefix of key @i@ up to (but not including) the switching
      -- bit @m@.
      mask :: Key -> Mask -> Prefix
      mask i m
        = maskW (natFromInt i) (natFromInt m)
      {-# INLINE mask #-}


      {--------------------------------------------------------------------
        Big endian operations
      --------------------------------------------------------------------}

      -- | The prefix of key @i@ up to (but not including) the switching
      -- bit @m@.
      maskW :: Nat -> Nat -> Prefix
      maskW i m
        = intFromNat (i .&. ((-m) `xor` m))
      {-# INLINE maskW #-}
      #+end_src

      and that's where these superfluous calls are coming from. There is an
      extra call I want to point out which arises from ~-m~ in ~maskW~. If you
      check the ~Num~ instance for ~Word~ you'll see this:

      #+begin_src haskell
      instance Num Word64 where
          ...
          negate (W64# x#)       = W64# (int64ToWord64# (negateInt64# (word64ToInt64# x#)))
          ...
      #+end_src

      Which also does conversion! Why this is the case and not something like
      ~maxBound - x~ or even a call to a primop like ~0 - x~ I don't know.

      So I tried to fix it with this version of [[https://github.com/doyougnu/containers/commits/wip/intmap-less-alloc][lookup]]:

      #+begin_src Haskell
      lookup :: Key -> IntMap a -> Maybe a
      lookup !k = go
        where
          go (Bin p m l r)  | nomatchNat k' p' m' = Nothing
                            | zeroNat    k' m'    = go l
                            | otherwise           = go r
            where p' = natFromInt p
                  m' = natFromInt m
                  k' = natFromInt k
          go (Tip kx x) | k == kx   = Just x
                           | otherwise = Nothing
          go Nil = Nothing
      #+end_src
      Which just converts these Bin parameters /once/ and then uses Nat
      versions to do the Bit manipulation. If we look at the core and stg the
      situation looks much improved:
      #+begin_src haskell
      $wlookup
        = \ @a_s5MgS ww_s5MgX w_s5MgU ->
            let { k'_s5ES7 = int2Word# ww_s5MgX } in
            join {
              exit_X9 dt_d5BQu x_a5q9D
                = case ==# ww_s5MgX dt_d5BQu of {
                    __DEFAULT -> Nothing;
                    1# -> Just x_a5q9D
                  } } in
            joinrec {
              go3_s5ECW ds_d5wR4
                = case ds_d5wR4 of {
                    Bin dt_d5BQs dt1_d5BQt l_a5q9x r_a5q9y ->
                      let { m'_s5ECZ = int2Word# dt1_d5BQt } in
                      case neWord#
                             (and# k'_s5ES7 (xor# (minusWord# 0## m'_s5ECZ) m'_s5ECZ))
                             (int2Word# dt_d5BQs)
                      of {
                        __DEFAULT ->
                          case and# k'_s5ES7 m'_s5ECZ of {
                            __DEFAULT -> jump go3_s5ECW r_a5q9y;
                            0## -> jump go3_s5ECW l_a5q9x
                          };
                        1# -> Nothing
                      };
                    Tip dt_d5BQu x_a5q9D -> jump exit_X9 dt_d5BQu x_a5q9D;
                    Nil -> Nothing
                  }; } in
            jump go3_s5ECW w_s5MgU
      #+end_src

      That's 3 ~int2Word~'s instead of 4, and no calls to ~word2Int~! This is
      even more clear in the ~stg~:

      #+begin_src haskell
      $wlookup =
          \r [ww_s5TXH w_s5TXI]
              case int2Word# [ww_s5TXH] of k'_s5TXJ {
              __DEFAULT ->
              let-no-escape {
                exit_s5TXK =
                    \r [dt_s5TXL x_s5TXM]
                        case ==# [ww_s5TXH dt_s5TXL] of {
                          __DEFAULT -> Nothing [];
                          1# -> Just [x_s5TXM];
                        };
              } in
                let-no-escape {
                  Rec {
                  go3_s5TXO =
                      \r [ds_s5TXP]
                          case ds_s5TXP of {
                            Bin dt_s5TXR dt1_s5TXS l_s5TXT r_s5TXU ->
                                case int2Word# [dt1_s5TXS] of m'_s5TXV {
                                __DEFAULT ->
                                case int2Word# [dt_s5TXR] of sat_s5TXZ {
                                __DEFAULT ->
                                case minusWord# [0## m'_s5TXV] of sat_s5TXW {
                                __DEFAULT ->
                                case xor# [sat_s5TXW m'_s5TXV] of sat_s5TXX {
                                __DEFAULT ->
                                case and# [k'_s5TXJ sat_s5TXX] of sat_s5TXY {
                                __DEFAULT ->
                                case neWord# [sat_s5TXY sat_s5TXZ] of {
                                  __DEFAULT ->
                                      case and# [k'_s5TXJ m'_s5TXV] of {
                                        __DEFAULT -> go3_s5TXO r_s5TXU;
                                        0## -> go3_s5TXO l_s5TXT;
                                      };
                                  1# -> Nothing [];
                                };
                                };
                                };
                                };
                                };
                                };
                            Tip dt_s5TY2 x_s5TY3 -> exit_s5TXK dt_s5TY2 x_s5TY3;
                            Nil -> Nothing [];
                          };
                  end Rec }
                } in  go3_s5TXO w_s5TXI;
              };
      #+end_src

      In the stg we see a reduction in ~case~ expressions from 11 to 7! However,
      the change doesn't show up in /any/ benchmarking as a positive. IntMap
      benchmarks are unchanged, allocations of ~lookup~ are unchanged in a ticky
      of ~spectral/simple/Main.hs~ with a patched ~GHC~. When compiling packages
      with the patched GHC allocations were actually found to /get worse/! The
      reason is in the ~Cmm~ code. Essentially the patched version produces
      better ~stg~ but gets optimized away at ~Cmm~ anyway. Furthermore
      because we allocate for ~k~ in the closure of the patched version the
      patched ~Cmm~ code maintains an additional register, whereas the
      un-patched version doesn't. Thus we have another promising lead but a
      failure in the end.


** Avoid allocations in substitutions in the simplifier

*** Hypothesis
    Benchmarking indicates that a large amount of allocations occur in the
    simplifier. We should seek to understand why that is the case.

*** Status
    Unexplored

*** Evidence

*** The Fix

*** Relevant Issues
    - [[https://gitlab.haskell.org/ghc/ghc/-/issues/19537][Opportunity for increased sharing during substitution]]
    - [[https://gitlab.haskell.org/ghc/ghc/-/issues/19538][Annotating Core to avoid unnecessary traversal of large subexpressions]]

*** Relevant Merge Requests
    - Sylvain Henry implemented a fix only in ~Tidy~ in [[https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5267][!5267]] but there is a bug
      and some variables aren't correctly renamed leading to test failures.

*** Relevant Patches

*** Courses of Action
    1. Read through [[https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5267][!5267]]
    2. Fix [[https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5267][!5267]] benchmark it. Try it out in ~GHC.Core.substExpr~ and
       ~GHC.Core.TyCo.Subst~

** Optimize the pretty printing during code generation

*** Hypothesis
    Code generation is a significant chunk of compile time. According to Matt
    Pickering some pretty printing functions perform a lot of allocation during
    this phase which leads to a slow down.

*** Status
    Unexplored

*** Evidence

*** The Fix
    We'll need to optimize pretty printing. Exactly what needs optimization, and
    how is to be determined.

*** Relevant Issues

*** Relevant Merge Requests

*** Relevant Patches

*** Courses of Action
    1. benchmark pretty printing during code generation to identify candidate
       functions for optimization.
    2. Ticky profile these functions to get some hard evidence.

* Knowledge Sharing
  It would be nice to know:

** Is every IntMap necessary?
   - Consider this passage from Richard Eisenberg, in ghc-devs Vol215 issue 5:
     #+begin_quote
     One piece I'm curious about, reading this thread: why do we have so many IntMaps
     and operations on them? Name lookup is a fundamental operation a compiler must
     do, and that would use an IntMap: good. But maybe there are other IntMaps used
     that are less necessary. A key example: whenever we do substitution, we track an
     InScopeSet, which is really just an IntMap. This InScopeSet remembers the name
     of all variables in scope, useful when we need to create a new variable name
     (this is done by uniqAway). Yet perhaps the tracking of these in-scope variables
     is very expensive and comprises much of the IntMap time. Might it be better just
     to always work in a monad capable of giving fresh names? We actually don't even
     need a monad, if that's too annoying. Instead, we could just pass around an
     infinite list of fresh uniques. This would still be clutterful, but if it grants
     us a big speed improvement, the clutter might be worth it.

     The high-level piece here is that there may be good things that come from
     understanding where these IntMaps arise.
     #+end_quote